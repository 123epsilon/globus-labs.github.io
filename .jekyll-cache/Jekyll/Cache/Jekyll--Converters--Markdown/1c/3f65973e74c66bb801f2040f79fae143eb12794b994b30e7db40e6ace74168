I"<<h1 id="motivation">Motivation</h1>

<p>Imagine you have a computation expressed in Python that has asynchronous tasks that are inherently parallelizable.
What do you do? 
Maybe you reach for <code class="language-plaintext highlighter-rouge">threading</code>, but that‚Äôs a mistake since in Python threads can‚Äôt run in parallel (thanks <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">GIL</a> üò†).
Maybe you reach for <code class="language-plaintext highlighter-rouge">multiprocessing</code>. 
That‚Äôd be a valid solution as long as you‚Äôre comfortable writing such code, which often involves synchronization logic, <em>and</em> you don‚Äôt need to distribute across compute resources.
But, what if you don‚Äôt want to worry about low-level code and in fact you want to distribute to 10, 100, or 1000 possibly heterogenous compute nodes?
For that use case, you should probably reach for <a href="https://parsl-project.org/">Parsl</a>.</p>

<p>Some examples of the kind of work that Parsl ends up being a useful tool for:</p>

<ul>
  <li>DNA sequence analysis, which is computationally-intensive, data-intensive, and requires fault tolerant and efficient utilization of infrastructure across multiple compute nodes and even sites</li>
  <li>X-ray microtomography to characterize the neuroanatomical structure of brain volumes, for example at the <a href="https://www.aps.anl.gov/Imaging">Argonne Advanced Photon Source</a> where work is outsourced to <a href="https://www.alcf.anl.gov/">Argonne‚Äôs Leadership Computing Facility</a></li>
  <li>Cosmology simulation, for example to simulate images from each of the <a href="https://www.lsst.org/">Large Synoptic Survey Telescope</a>‚Äôs 189 sensors</li>
</ul>

<h1 id="parsl-primitives">Parsl Primitives</h1>

<p>Parsl (<strong>par</strong>allel <strong>s</strong>cripting <strong>l</strong>ibrary) is a Python package that makes defining and executing parallel computations ergonomic. 
Parsl‚Äôs principal value proposition is management and scheduling of asynchronous and concurrent tasks in fault tolerant ways, at exascale.
It delivers on this proposition by exposing exceedingly simple primitives that can be composed functionally to build workflows.
The paramount primitives<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup> are a decorator <code class="language-plaintext highlighter-rouge">python_app</code>, which wraps conventional<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">2</a></sup> Python functions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">python_app</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Hello World!'</span>
</code></pre></div></div>

<p>and an abstraction for operating on file-like objects called <code class="language-plaintext highlighter-rouge">File</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">python_app</span>
<span class="k">def</span> <span class="nf">sort_numbers</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[]):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">filepath</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">readlines</span><span class="p">()]</span>
        <span class="n">strs</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">strs</span>

<span class="n">unsorted_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">'unsorted_numbers.txt'</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">sort_numbers</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">unsorted_file</span><span class="p">])</span>
</code></pre></div></div>

<p>Each Python function wrapped by <code class="language-plaintext highlighter-rouge">python_app</code> (generally called an <em>app</em>) returns either an <code class="language-plaintext highlighter-rouge">AppFuture</code> or a <code class="language-plaintext highlighter-rouge">DataFuture</code> (depending on whether an app produces a <code class="language-plaintext highlighter-rouge">File</code> as the product of the task), each of which inherit and extend <code class="language-plaintext highlighter-rouge">concurrent.futures.Future</code>.
Therefore execution of an app is asynchronous and results need to await<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> resolution:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">python_app</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">'Hello World!'</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">app_future</span> <span class="o">=</span> <span class="n">hello</span><span class="p">()</span>
<span class="c1"># Check if the app_future is resolved, which it won't be
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="s">'Done: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">app_future</span><span class="p">.</span><span class="n">done</span><span class="p">()))</span>
<span class="n">Done</span><span class="p">:</span> <span class="bp">False</span>
<span class="c1"># Print the result of the app_future. Note: this
# call will block and wait for the future to resolve
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="s">'Result: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">app_future</span><span class="p">.</span><span class="n">result</span><span class="p">()))</span>
<span class="n">Result</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="s">'Done: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">app_future</span><span class="p">.</span><span class="n">done</span><span class="p">()))</span>
<span class="n">Done</span><span class="p">:</span> <span class="bp">True</span>
</code></pre></div></div>

<h1 id="composing-a-workflow-in-parsl">Composing a workflow in Parsl</h1>

<p>With these primitives in hand, which you can compose, you‚Äôre ready to build arbitrarily complicated workflows.
For example suppose you wanted to estimate a quantity; in particular the integral $I$ of a nontrivial integrand</p>

\[I = \int_0^1 \frac{\sin x}{x + \cos^2 x}\, \d x\]

<p>Under fairly weak assumptions<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> (that our integrand satisfies) we know by the <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers#Strong_law">Strong Law of Large Numbers</a> that</p>

\[\lim_{N \rightarrow \infty} \frac{1}{N} \sum_i^N f(U_i) = E [f(U)] = \int_0^1 f(U)\, \d U\]

<p>where $f(x) =  \frac{\sin x}{x + \cos^2 x}$ and $U$ is a random variable distributed uniformly.
This naturally suggests itself to being implemented as an ‚Äúembarassingly parallel‚Äù computation: draw lots of samples from the uniform disitrubtion, apply $f$ to each sample, then average the result.
We can implement this workflow in a straightforward way using Parsl primitives:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">python_app</span>
<span class="k">def</span> <span class="nf">monte_carlo</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="o">@</span><span class="n">python_app</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_draws</span> <span class="o">=</span> <span class="mi">100</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fus</span> <span class="o">=</span> <span class="p">[</span><span class="n">monte_carlo</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_draws</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">integ</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">fus</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="s">"Average: {:.5f}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">integ</span><span class="p">.</span><span class="n">result</span><span class="p">()))</span>
<span class="n">Average</span><span class="p">:</span> <span class="mf">0.35094</span>
</code></pre></div></div>

<p>This result is considerably different from the correct answer as computed by a numerical integrator (0.36358 to five decimal places) owing to the paltry number of draws. 
We can certainly remedy this by increasing the number of draws but on a single machine (or a single core) we would just be linearly increasing the runtime.
Parsl raison d‚Äô√™tre is scaling this workflow (and those much more complicated) up to ~100,000 parallel workers, such that <strong>absolutely no amendment to the logic of the computation</strong> is necessary on your part.</p>

<h1 id="gory-details">Gory details</h1>

<p>How does Parsl work?
The best discussion of the internals can be found in <a href="https://dl.acm.org/doi/10.1145/3307681.3325400">Babuji et al.</a> but briefly Parsl is built on top an execution management engine called <code class="language-plaintext highlighter-rouge">DataFlowKernel</code> that manages tasks scheduling and tasks dependencies (represented as a graph).
In order to make itself more accessible to a typical scientific user, Parsl also wraps several interfaces available on scientific clusters and supercomputers as <code class="language-plaintext highlighter-rouge">Provider</code>s; currently, Parsl implements <code class="language-plaintext highlighter-rouge">Provider</code>s for Slurm, Torque/PBS, HTCondor, Cobalt, GridEngine, AWS, Google Cloud, Jetstream, and Kubernetes.
Parsl also wraps the job launchers fork, srun, aprun, mpiexec, GNU parallel as a <code class="language-plaintext highlighter-rouge">Launcher</code>.</p>

<p align="center">
  <img src="/images/blog/dataflowkernel.png" />
</p>

<p>To support diverse execution requirements (e.g. high throughput vs. low latency) Parsl provides a modular <code class="language-plaintext highlighter-rouge">Executor</code> interface and implementations that support three common use cases:</p>

<p align="center">
  <img src="/images/blog/executors.png" width="1000" />
</p>

<p>More about the implementation can be found in the <a href="https://dl.acm.org/doi/10.1145/3307681.3325400">Parsl paper</a>, along with evaluation and comparison against similar tools.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Parsl is great if you want to do a lot of work in parallel but don‚Äôt want to write all of the bookkeeping and scheduling code yourself! 
As already mentioned a deeper technical discussion is available in the <a href="https://dl.acm.org/doi/10.1145/3307681.3325400">Parsl paper</a>.
Documentation is available at the <a href="https://parsl.readthedocs.io/en/stable/">Parsl project homepage</a> and you can even experiment with it right now in your browser using the project‚Äôs provided <a href="https://mybinder.org/v2/gh/Parsl/parsl-tutorial/master">binder instance</a>.
The project is <a href="https://github.com/Parsl/parsl">open source</a> and very welcoming of PR submissions.</p>

<h1 id="foonotesbibliography">Foonotes/Bibliography</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>There is actually another decorator called <code class="language-plaintext highlighter-rouge">bash_app</code> that enables integrating bash tasks into a workflow (and therefore arbitrary executables).¬†<a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>For the most part; consult the documentation for <a href="https://parsl.readthedocs.io/en/stable/userguide/overview.html#parameter-passing">caveats</a>.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>In the conventional sense rather than the <code class="language-plaintext highlighter-rouge">await</code> sense.¬†<a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>$f$ of $\int f \d x$ should be bounded and real-valued on the domain of integration.¬†<a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET